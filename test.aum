import FileSystem.File (
    FileHandle,
    open,
    close,
    read,
    readSafe,
    write,
    seek,
    SEEK_SET,
    tell
);

import Standard.Buffer (
    Buffer,
    length,
    getSpan,
    destroyFree
);

import System (
    SystemCapability,
    acquireSystem,
    releaseSystem,
    system
);

import FileSystem (
    FileSystemCapability,
    acquireFileSystem,
    releaseFileSystem
);

module body Test is

    function main(root: RootCapability): ExitCode is
        var mut_root: RootCapability := root;
        test(testFileNotExist(&!mut_root), "Nonexistent file test");
        test(testFileExist(&!mut_root), "Existent file test");
        test(testReadFile(&!mut_root), "Read file test");
        test(testWriteFile(&!mut_root), "Write new file test");
        test(testSeekInFile(&!mut_root), "Seek in file test");
        surrenderRoot(mut_root);

        return ExitSuccess();
    end;

    generic [R: Region]
    function testFileNotExist(root: &![RootCapability, R]): Bool is
        var fs: FileSystemCapability := acquireFileSystem(root);
        let maybe_fh: Option[FileHandle] := open(&!fs, "nonexist", "r");
        case maybe_fh of
            when None do
                releaseFileSystem(fs);
                return true;
            when Some(value as fh: FileHandle) do
                close(fh);
                releaseFileSystem(fs);
                return false;
        end case;
    end;

    generic [R: Region]
    function testFileExist(root: &![RootCapability, R]): Bool is
        var sys: SystemCapability := acquireSystem(&~root);
        var fs: FileSystemCapability := acquireFileSystem(&~root);
        system(&!sys, "touch exist");
        let maybe_fh: Option[FileHandle] := open(&!fs, "exist", "r");

        case maybe_fh of
            when None do
                system(&!sys, "rm exist");
                releaseSystem(sys);
                releaseFileSystem(fs);
                return false;
            when Some(value as fh: FileHandle) do
                close(fh);
                system(&!sys, "rm exist");
                releaseSystem(sys);
                releaseFileSystem(fs);
                return true;
        end case;
    end;

    generic [R: Region]
    function testReadFile(root: &![RootCapability, R]): Bool is 
        var fs: FileSystemCapability := acquireFileSystem(root);
        let maybe_fh: Option[FileHandle] := open(&!fs, "lipsum.txt", "r");
        case maybe_fh of 
            when None do
                releaseFileSystem(fs);
                return false;
            when Some(value as fh: FileHandle) do
                let count: Index := 360;
                let buf: Buffer[Nat8] := read(&fh, count);
                printLn(getSpan(&buf, 0, count - 1));
                destroyFree(buf);
                close(fh);
                releaseFileSystem(fs);
                return true;
        end case;
    end;

    generic [R: Region]
    function testWriteFile(root: &![RootCapability, R]): Bool is
        var sys: SystemCapability := acquireSystem(&~root);
        var fs: FileSystemCapability := acquireFileSystem(&~root);
        let maybe_fh: Option[FileHandle] := open(&!fs, "newfile.txt", "w");
        case maybe_fh of
            when None do
                releaseFileSystem(fs);
                releaseSystem(sys);
                return false;
            when Some(value: FileHandle) do
                var fh: FileHandle := value;
                let written: Index := write(&!fh, "Hello, there!\n");
                close(fh);
                system(&!sys, "echo newfile.txt contains: && cat newfile.txt && rm newfile.txt");
                releaseFileSystem(fs);
                releaseSystem(sys);
                return written = 14;
        end case;
    end;

    generic [R: Region]
    function testSeekInFile(root: &![RootCapability, R]): Bool is
        var sys: SystemCapability := acquireSystem(&~root);
        var fs: FileSystemCapability := acquireFileSystem(&~root);
        system(&!sys, "echo seektest > seektest.txt");
        let maybe_fh: Option[FileHandle] := open(&!fs, "seektest.txt", "r");
        case maybe_fh of
            when None do
                releaseFileSystem(fs);
                releaseSystem(sys);
                return false;
            when Some(value as fh: FileHandle) do
                seek(&fh, 4, SEEK_SET);
                let count: Index := 4;
                let loc: Int64 := tell(&fh);
                let maybe_buf: Option[Buffer[Nat8]] := readSafe(&fh, count);
                close(fh);
                system(&!sys, "rm seektest.txt");
                case maybe_buf of
                    when None do
                        releaseSystem(sys);
                        releaseFileSystem(fs);
                        return false;
                    when Some(value as buf: Buffer[Nat8]) do
                        printLn(getSpan(&buf, 0, count - 1));
                        var retval: Bool := false;
                        if (length(&buf) = count) and (loc = 4) then
                            retval := true;
                        end if;
                        destroyFree(buf);
                        releaseSystem(sys);
                        releaseFileSystem(fs);
                        return retval;
                end case;
        end case;
    end;

    function test(truth: Bool, title: Span[Nat8, Static]): Unit is
        print("Test '");
        print(title);
        if truth then
            printLn("' Passed");
        else
            printLn("' Failed");
        end if;
        return nil;
    end;
        

end module body.

