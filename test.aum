import IO.File (
    FileHandle,
    open,
    close,
    read,
    write
);

import Standard.Buffer (
    Buffer,
    getSpan,
    destroyFree
);

import System (
    SystemCapability,
    acquireSystem,
    releaseSystem,
    system
);

import FileSystem (
    FileSystemCapability,
    acquireFileSystem,
    releaseFileSystem
);

module body Test is

    function main(root: RootCapability): ExitCode is
        var mut_root: RootCapability := root;
        var fs: FileSystemCapability := acquireFileSystem(&!mut_root);
        var sys: SystemCapability := acquireSystem(&!mut_root);
        test(testFileNotExist(&!fs), "Nonexistent file test");
        test(testFileExist(&!fs, &!sys), "Existent file test");
        test(testReadFile(&!fs), "Read file test");
        test(testWriteFile(&!fs, &!sys), "Write new file test");
        releaseFileSystem(fs);
        releaseSystem(sys);

        surrenderRoot(mut_root);

        return ExitSuccess();
    end;

    generic [R: Region]
    function testFileNotExist(fs: &![FileSystemCapability, R]): Bool is
        let maybe_fh: Option[FileHandle] := open(fs, "nonexist", "r");
        case maybe_fh of
            when None do
                return true;
            when Some(value as fh: FileHandle) do
                close(fh);
                return false;
        end case;
    end;

    generic [R: Region, Q: Region]
    function testFileExist(fs: &![FileSystemCapability, R], sys: &![SystemCapability, Q]): Bool is
        borrow my_sys: &![SystemCapability, S] := sys do
            system(my_sys, "touch exist");
            let maybe_fh: Option[FileHandle] := open(fs, "exist", "r");

            case maybe_fh of
                when None do
                    system(my_sys, "rm exist");
                    return false;
                when Some(value as fh: FileHandle) do
                    close(fh);
                    system(my_sys, "rm exist");
                    return true;
            end case;
        end borrow;
    end;

    generic [R: Region]
    function testReadFile(fs: &![FileSystemCapability, R]): Bool is 
        let maybe_fh: Option[FileHandle] := open(fs, "lipsum.txt", "r");
        case maybe_fh of 
            when None do
                return false;
            when Some(value as fh: FileHandle) do
                let count: Index := 360;
                let buf: Buffer[Nat8] := read(&fh, count);
                printLn(getSpan(&buf, 0, count - 1));
                destroyFree(buf);
                close(fh);
                return true;
        end case;
    end;

    generic [R: Region, Q: Region]
    function testWriteFile(fs: &![FileSystemCapability, R], sys: &![SystemCapability, Q]): Bool is
        let maybe_fh: Option[FileHandle] := open(fs, "newfile.txt", "w");
        case maybe_fh of
            when None do
                return false;
            when Some(value: FileHandle) do
                var fh: FileHandle := value;
                let written: Index := write(&!fh, "Hello, there!\n");
                close(fh);
                system(sys, "echo newfile.txt contains: && cat newfile.txt && rm newfile.txt");
                return written = 14;
        end case;
    end;

    function test(truth: Bool, title: Span[Nat8, Static]): Unit is
        print("Test '");
        print(title);
        if truth then
            printLn("' Passed");
        else
            printLn("' Failed");
        end if;
        return nil;
    end;
        

end module body.

