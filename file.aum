pragma Unsafe_Module;

import Standard.Buffer (
    Buffer,
    initialize,
    safeInitialize,
    getSpanMut
);

import Austral.Memory (
    Pointer,
    spanToPointer,
    spanWriteToPointer
);

import FileSystem (
    FileSystemCapability
);

module body FileSystem.File is
    record FileHandle: Linear is
        handle: Index;
    end;
    
    generic [R: Region, Q: Region, P: Region]
    function open(fs: &![FileSystemCapability, R], pathname: Span[Nat8, Q], mode: Span[Nat8, P]): Option[FileHandle] is
        let path_ptr: Pointer[Nat8] := spanToPointer(pathname);
        let mode_ptr: Pointer[Nat8] := spanToPointer(mode);
        
        let handle: Index := openInner(path_ptr, mode_ptr);
        if handle <= 0 then
                return None();
        else
            return  Some(
                value => FileHandle(
                    handle => handle
                )
            );
        end if;
    end;

    function close(fh: FileHandle): Unit is
        let {handle: Index} := fh;
        closeInner(handle);
        return nil;
    end;

    generic [R: Region]
    function read(fh: &[FileHandle, R], count: Index): Buffer[Nat8] is
        var buf: Buffer[Nat8] := initialize(count, 0:Nat8);
        borrow bufref: &![Buffer[Nat8], BufReg] := &!buf do
            var data: Span![Nat8, BufReg] := getSpanMut(bufref, 0, count - 1);
            var ptr: Pointer[Nat8] := spanWriteToPointer(data);
            readInner(ptr, 1, count, fh->handle);
        end borrow;
        return buf;
    end;

    generic [R: Region]
    function readSafe(fh: &[FileHandle, R], count: Index): Option[Buffer[Nat8]] is
        var maybe_buf: Option[Buffer[Nat8]] := safeInitialize(count, 0:Nat8);
        case maybe_buf of
            when None do
                return None();
            when Some(value: Buffer[Nat8]) do
                var buf: Buffer[Nat8] := value;
                var data: Span![Nat8, R] := getSpanMut(&!buf, 0, count - 1);
                var ptr: Pointer[Nat8] := spanWriteToPointer(data);
                readInner(ptr, 1, count, fh->handle);
                return Some(value => buf);
        end case;
    end;

    generic [R: Region, Q: Region]
    function write(fh: &![FileHandle, R], buf: Span[Nat8, Q]): Index is
        let ptr: Pointer[Nat8] := spanToPointer(buf);
        let count: Index := spanLength(buf);
        return writeInner(ptr, 1, count, fh->handle);
    end;

    generic [R: Region]
    function seek(fh: &[FileHandle, R], offset: Int64, whence: Int32): Int32 is
        return seekInner(fh->handle, offset, whence);
    end;

    union SeekWhence: Free is
        case Set;
        case Current;
        case End;
    end;

    constant SEEK_SET: Int32 := 0;
    constant SEEK_CUR: Int32 := 1;
    constant SEEK_END: Int32 := 2;

    generic [R: Region]
    function tell(fh: &[FileHandle, R]): Int64 is
        return tellInner(fh->handle);
    end;

    pragma Foreign_Import(External_Name => "fopen");
    function openInner(pathname: Pointer[Nat8], mode: Pointer[Nat8]): Index is
    end;

    pragma Foreign_Import(External_Name => "fclose");
    function closeInner(fh: Index): Int64 is
    end;

    pragma Foreign_Import(External_Name => "fread");
    function readInner(ptr: Pointer[Nat8], size: Index, nmemb: Index, stream: Index): Index is
    end;

    pragma Foreign_Import(External_Name => "fwrite");
    function writeInner(ptr: Pointer[Nat8], size: Index, nmemb: Index, stream: Index): Index is
    end;

    pragma Foreign_Import(External_Name => "fseek");
    function seekInner(stream: Index, offset: Int64, whence: Int32): Int32 is
    end;

    pragma Foreign_Import(External_Name => "ftell");
    function tellInner(stream: Index): Int64 is
    end;

end module body.
